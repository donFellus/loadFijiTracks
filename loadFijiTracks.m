% loadFijiTracks loads .csv files generated by the FIJI plugin trackMate  
% and plots mean intensity values from the primary and secondary channels. 
% The .csv files must be stored in sequential folders named Cell1, Cell2, etc.
%
% Inputs:   
%           'FileID' : A unique identifier which is part of all the filenames 
%                      of the .csv files you wish to load from each Cell folder 
%   'Primary channel' : the name of the primary channel from trackMate
% 'Secondary channel' : the name of the secondary channel from trackMate
%     
% Notes: All input data sets must have two channels.
%
% Copyright (C) 2022, Kvalvaag project group - Oslo University Hospital 
% 
% loadFijiTracks is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% loadFijiTracks is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% <http://www.gnu.org/licenses/>

% Audun Kvalvaag, August 2020 (last modified 2022/03/09)

function outData = loadFijiTracks(varargin)

ip = inputParser;
ip.CaseSensitive = false;
ip.addOptional('condDir', [], @(x) ischar(x) && ~any(strcmpi(x,...
    {'Parameters', 'MovieSelector', 'IgnoreEmptyFolders'})));
ip.addParameter('MovieSelector', 'Cell', @ischar);
ip.addOptional('chNames', [], @iscell);
ip.addParameter('StrictSelector', true, @islogical);
ip.addParameter('IgnoreEmptyFolders', false, @islogical);
ip.addParameter('CohortBounds', [10 114]); % define cohort bounds
ip.addParameter('ErrorBar', true, @islogical); % set true if you want errorbars, false if not
ip.addParameter('BleachingCorrection', false, @islogical); % set true if bleaching correction in the secondary channel, false if not
ip.addParameter('BleachingFactor', []); % bleaching factor (must be measured on beforehand)
ip.addParameter('MaxIntensityThreshold1', 0); % intensity threshold for the primary channel
ip.addParameter('MaxIntensityThreshold2', 5000); % intensity threshold for the secondary channel
ip.addParameter('nFrames', 112); % total number of frames per movie (for bleaching correction)
ip.addParameter('scaleCh2', true, @islogical); % set true to scale Ch2 relative to Ch1
ip.parse(varargin{:});

cohortBounds = ip.Results.CohortBounds;
bF = ip.Results.BleachingFactor;
condDir = ip.Results.condDir;
nFrames = ip.Results.nFrames;
maxIntensityThreshold1 = ip.Results.MaxIntensityThreshold1;
maxIntensityThreshold2 = ip.Results.MaxIntensityThreshold2;

if isempty(condDir)
    condDir = uigetdir(pwd, 'Select the ''condition'' folder:');
    if condDir==0
        tracks = [];
        return
    else
        condDir = [condDir filesep];
    end
end
if ~strcmp(condDir(end), filesep)
    condDir = [condDir filesep];
end

fprintf('Root directory: %s\n', condDir);

cellPath = recursiveDir(condDir, 2);

prompt0 = 'FileID: ';

fileID = input(prompt0, 's');

prompt1 = 'Set primary channel: ';
 
mCh = input(prompt1, 's');

prompt2 = 'Set secondary channel: ';
 
sCh = input(prompt2, 's');

% cell directories:
cellDirs = cellfun(@(i) getDirFromPath(i), cellPath, 'unif', 0);

idx = regexpi(cellDirs, ip.Results.MovieSelector, 'once');
[idx{cellfun(@isempty, idx)}] = deal(NaN);
idx = vertcat(idx{:});
if ip.Results.StrictSelector
    idx(idx~=1) = NaN;
end
idx = ~isnan(idx);
cellPath = cellPath(idx);

if isempty(cellPath)
    error(['No data found in: ' condDir]);
end

nc = numel(cohortBounds)-1;
bFn = bF/nFrames; % bleaching factor per frame
framerate = 3; % framerate

iLength = arrayfun(@(c) floor(max(cohortBounds([c c+1]))), 1:nc)*framerate;
cT = arrayfun(@(i) (-1:i-2), iLength, 'UniformOutput', false);
nCh = 2;
filePattern = fullfile(cellPath, ['*' fileID '*']);
i = numel(filePattern);

tracks = struct('Name', [], 'N', [], 'file', [], 'track', [], 'lifetime', [], 'quality', []);

res(1:i) = struct('interpTracks', [], 'interpSigLevel', []);

numberincohort = zeros(i,nc);

for k = 1 : i
    theFiles = dir(filePattern{k});
    [~,baseFileName{k},~] = fileparts(theFiles.name);
    fullFileName = fullfile(cellPath{k}, baseFileName{k});
    fprintf(1, 'Now reading %s\n', fullFileName);
    % Now do whatever you want with this file name,
    % such as reading it in as an image array with imread()
    files = readtable(fullFileName);
    nt = max(files.TRACK_ID);
    file = sortrows(files, 3);
    % loop through data sets, generate cohorts for each
    tracks = struct([]);
    for n = 1:nt
        tracks(n).A(:,1) = files.MEAN_INTENSITY_CH1(files.TRACK_ID == n);
        tracks(n).A(:,2) = files.MEAN_INTENSITY_CH2(files.TRACK_ID == n);
        tracks(n).lft = numel(tracks(n).A(:,1));
        tracks(n).maxA1 = max(tracks(n).A(:,1));
        tracks(n).maxA2 = max(tracks(n).A(:,2));
    end
    temp = struct2table(tracks);
    temp = sortrows(temp,'lft'); % sort rows according to lifetime
    temp = table2struct(temp);
        for ch = 1:nCh % channels
        % interpolate tracks to mean cohort length
            for c = 1:nc % cohorts
                % tracks in current cohort
                cidx = find(cohortBounds(c)<=[temp.lft] & [temp.lft]<cohortBounds(c+1) & [temp.maxA1] > maxIntensityThreshold1...
                    & [temp.maxA2] > maxIntensityThreshold2);
                
                ntc = numel(cidx);   % numbers of tracks in each cohort  
                numberincohort(k,c)=ntc;
                if ntc>0
                    interpTracks = zeros(ntc,iLength(c));
                   % sigma_rMat = zeros(ntc,iLength(c));
                    lft = [temp.lft];
                    cLengths = lft(cidx);
                    % loop through track lengths within cohort
                    for t = 1:ntc
                        % align to track start
                        if ip.Results.BleachingCorrection && ch == 2
                            for b = 1:cLengths(t)
                                temp(cidx(t)).A(b,ch) = temp(cidx(t)).A(b,ch) + (temp(cidx(t)).A(b,ch) * bFn * (-1+b)); % bleaching correction in the secondary channel increasing with the factor bFn * the number of frames - 1
                            end
                            A = temp(cidx(t)).A(:,ch);
                        else
                            A = temp(cidx(t)).A(:,ch);
                        end
                        % interpolate to mean length
                        xi = linspace(1,cLengths(t), iLength(c));
                        interpTracks(t,:) = interp1(1:cLengths(t), A, xi, 'pchip');
                    end
                    res(k).interpTracks{ch,c} = interpTracks;
                else
                    res(k).interpTracks{ch,c} = NaN(1,iLength(c));
                end
                if size(res(k).interpTracks{ch,c}, 1) > 1
                    res(k).A{c}(:,ch) = mean(res(k).interpTracks{ch,c});
                    res(k).maxA{c}(:,ch) = max(res(k).A{c}(:,ch));
                else
                    res(k).A{c}(:,ch) = res(k).interpTracks{ch,c};
                    res(k).maxA{c}(:,ch) = max(res(k).A{c}(:,ch));
                end
            end
        end
end
for c = 1:nc
    tot_ntc = sum(numberincohort(:,c)); %total number of tracks in cohort
    if tot_ntc > 1
        for k = 1:i
            if ip.Results.scaleCh2
                sf = res(k).maxA{c}(1)/res(k).maxA{c}(2); % scale secondary channel according to primary channel
            else
                sf = 1;
            end
            res(k).A{c}(:,2) = res(k).A{c}(:,2).*sf;
            % smooth line plots by moving average
            data(c).mA(k,:) = smooth(res(k).A{c}(:,1)); 
            data(c).sA(k,:) = smooth(res(k).A{c}(:,2));
        end
        if i > 1
            % calculate mean and SEM
            avg_mA = nanmean(data(c).mA);
            std_mA = nanstd(data(c).mA);
            SEM_mA = std_mA./sqrt(size(data(c).mA, 1));
            SEM_mAub = avg_mA+SEM_mA;
            SEM_mAlb = avg_mA-SEM_mA;
            avg_sA = nanmean(data(c).sA);
            std_sA = nanstd(data(c).sA);
            SEM_sA = std_sA./sqrt(size(data(c).sA, 1));
            SEM_sAub = avg_sA+SEM_sA;
            SEM_sAlb = avg_sA-SEM_sA;
        else
            avg_mA = data(c).mA;
            SEM_mA = std(res(1).A{c}(:,1));
            SEM_mAub = avg_mA+SEM_mA;
            SEM_mAlb = avg_mA-SEM_mA;
            avg_sA = data(c).sA;
            SEM_sA = std(res(1).A{c}(:,2));
            SEM_sAub = avg_sA+SEM_sA;
            SEM_sAlb = avg_sA-SEM_sA;
        end
        %if c == 1
            figure(c);
        % end
        hold on
        % generate filled errorbars 
        if ip.Results.ErrorBar
            for s = 1:iLength(c)-1
                mAM(s) = patch([s s s+1 s+1], [SEM_mAlb(s) SEM_mAub(s) SEM_mAub(s+1) SEM_mAlb(s+1)], 'c');
                mAM(s).EdgeColor = 'none';
                mAM(s).FaceAlpha = .3;
                sAM(s) = patch([s s s+1 s+1], [SEM_sAlb(s) SEM_sAub(s) SEM_sAub(s+1) SEM_sAlb(s+1)], 'm');
                sAM(s).EdgeColor = 'none';                
                sAM(s).FaceAlpha = .3;
            end
        end
        plot(avg_mA, 'LineWidth', 2, 'color', 'c');
        XLim = cT{1,c}(1,end);
        xlim([0 XLim]);
        xlabel('(s)');
        ylabel('MFI (a.u.)');
        plot(avg_sA, 'LineWidth', 2, 'color', 'm');
        legend(mCh, sCh);
        ylim=get(gca,'ylim');
        text(0, ylim(1) + ylim(1).*0.2, ['n: ', num2str(tot_ntc), ' tracks']);
    end
    outData(c).avg(:,1) = avg_mA;
    outData(c).SEM(:,1) = SEM_mA;
    outData(c).avg(:,2) = avg_sA;
    outData(c).SEM(:,2) = SEM_sA;
end
end
